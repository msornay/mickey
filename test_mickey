#!/usr/bin/env bash
# Lean sanity tests for the mickey script.
# Tests argument parsing, usage output, and script structure.
# Does NOT require Docker â€” only validates the script itself.
set -euo pipefail

MICKEY="$(cd "$(dirname "$0")" && pwd)/mickey"
pass=0
fail=0

assert_exits() {
    local expected=$1 desc=$2; shift 2
    local actual=0
    "$@" >/dev/null 2>&1 || actual=$?
    if [[ $actual -eq $expected ]]; then
        pass=$((pass + 1)); echo "ok   - $desc"
    else
        fail=$((fail + 1)); echo "FAIL - $desc (expected exit $expected, got $actual)"
    fi
}

assert_output_matches() {
    local pattern=$1 desc=$2; shift 2
    local output
    output=$("$@" 2>&1) || true
    if echo "$output" | grep -qE "$pattern"; then
        pass=$((pass + 1)); echo "ok   - $desc"
    else
        fail=$((fail + 1)); echo "FAIL - $desc (output missing /$pattern/)"
    fi
}

# -- Script structure --
assert_exits 0 "script passes bash -n syntax check" bash -n "$MICKEY"

# -- No args --
assert_exits 1 "no args exits 1" "$MICKEY"
assert_output_matches "^Usage:" "no args shows usage" "$MICKEY"

# -- Unknown command --
assert_exits 1 "unknown command exits 1" "$MICKEY" badcmd
assert_output_matches "^Usage:" "unknown command shows usage" "$MICKEY" badcmd

# -- hire: missing name --
assert_exits 1 "hire without name exits 1" "$MICKEY" hire
assert_output_matches "mickey hire" "hire without name shows correct usage" "$MICKEY" hire

# -- whip: argument parsing --
assert_exits 1 "whip --model without value exits 1" "$MICKEY" whip --model
assert_exits 1 "whip -j without value exits 1" "$MICKEY" whip -j
assert_exits 1 "whip -j 0 exits 1" "$MICKEY" whip -j 0
assert_exits 1 "whip -j negative exits 1" "$MICKEY" whip -j -1
assert_exits 1 "whip -j non-numeric exits 1" "$MICKEY" whip -j abc
assert_output_matches "positive integer" "whip -j 0 shows error" "$MICKEY" whip -j 0
assert_output_matches "positive integer" "whip -j abc shows error" "$MICKEY" whip -j abc

# -- sh: missing name --
assert_exits 1 "sh without name exits 1" "$MICKEY" sh
assert_output_matches "mickey sh" "sh without name shows correct usage" "$MICKEY" sh

# -- fire: missing name --
assert_exits 1 "fire without name exits 1" "$MICKEY" fire
assert_output_matches "mickey fire" "fire without name shows correct usage" "$MICKEY" fire

# -- Agent rules content --
assert_exits 0 "AGENT_RULES variable is defined" grep -q "^AGENT_RULES=" "$MICKEY"
assert_exits 0 "agent rules contain workspace layout" grep -q "Workspace layout" "$MICKEY"
assert_exits 0 "agent rules contain producing output" grep -q "Producing output" "$MICKEY"
assert_exits 0 "agent rules contain sanity test requirement" grep -q "make test" "$MICKEY"
assert_exits 0 "agent rules contain wip directory" grep -q 'wip/' "$MICKEY"
assert_exits 0 "agent rules contain deployment awareness" grep -q "Deployment awareness" "$MICKEY"
assert_exits 0 "agent rules mention workspace-level TODO.md" grep -q 'WORKSPACE_DIR/TODO.md' "$MICKEY"
assert_exits 0 "agent rules do NOT contain review process" bash -c "! grep -q 'Reviewing patches' '$MICKEY'"
assert_exits 0 "no patch/ directory references in agent rules" bash -c "! grep -q 'WORKSPACE_DIR/patch/' '$MICKEY'"

# -- am: merge-queue cleanup and push --
assert_exits 0 "am cleans up empty merge-queue dirs" grep -q 'rmdir' "$MICKEY"
assert_exits 0 "am tracks applied repos for push" grep -q 'applied_repos' "$MICKEY"
assert_exits 0 "am push uses applied_repos array" grep -q 'applied_repos\[@\]' "$MICKEY"

# -- Agent output prefixing --
assert_exits 0 "whip defines color palette array" grep -q 'colors=(' "$MICKEY"
assert_exits 0 "whip pipes agent output through awk prefix" grep -q 'awk -v name=' "$MICKEY"
assert_exits 0 "awk uses fflush for unbuffered output" grep -q 'fflush()' "$MICKEY"

# -- Usage text --
assert_output_matches "whip" "usage mentions whip command" "$MICKEY"
assert_output_matches "am" "usage mentions am command" "$MICKEY"
assert_output_matches "status" "usage mentions status command" "$MICKEY"
assert_output_matches "wip/" "usage mentions wip directory" "$MICKEY"

# -- Status command structure --
assert_exits 0 "status command is handled in case statement" grep -q "status)" "$MICKEY"
assert_exits 0 "status shows Work In Progress section" grep -q "Work In Progress" "$MICKEY"
assert_exits 0 "status shows Merge Queue section" grep -q "Merge Queue" "$MICKEY"

# -- Whip activity watcher --
assert_exits 0 "whip has activity watcher background loop" grep -q "activity watcher" "$MICKEY"
assert_exits 0 "watcher reports claimed TODOs" grep -q "CLAIMED" "$MICKEY"
assert_exits 0 "watcher reports submitted patches" grep -q ">>> PATCH" "$MICKEY"

# -- Secret detection structure --
assert_exits 0 "SECRET_PATTERNS array is defined" grep -q "^SECRET_PATTERNS=" "$MICKEY"
assert_exits 0 "check_patch_secrets function is defined" grep -q "^check_patch_secrets()" "$MICKEY"
assert_exits 0 "am command calls check_patch_secrets" grep -q "check_patch_secrets" "$MICKEY"
assert_exits 0 "secret scan prints warning banner" grep -q "WARNING.*secret\|WARNING.*credential\|WARNING.*leak" "$MICKEY"

# -- PII detection structure --
assert_exits 0 "PII_PATTERNS array is defined" grep -q "^PII_PATTERNS=" "$MICKEY"
assert_exits 0 "check_patch_pii function is defined" grep -q "^check_patch_pii()" "$MICKEY"
assert_exits 0 "am command calls check_patch_pii" grep -q "check_patch_pii" "$MICKEY"
assert_exits 0 "pii scan prints warning banner" grep -q "WARNING.*personal information" "$MICKEY"

# -- Secret detection functional tests --
# Source just the patterns and function from mickey (skip the main case/esac)
TMPDIR_TEST=$(mktemp -d)
trap 'rm -rf "$TMPDIR_TEST"' EXIT

# Extract the patterns and functions from mickey
eval "$(sed -n '/^SECRET_PATTERNS=/,/^)/p' "$MICKEY")"
eval "$(sed -n '/^check_patch_secrets()/,/^}/p' "$MICKEY")"
eval "$(sed -n '/^PII_PATTERNS=/,/^)/p' "$MICKEY")"
eval "$(sed -n '/^check_patch_pii()/,/^}/p' "$MICKEY")"

# Test: clean patch (no secrets)
cat > "$TMPDIR_TEST/clean.patch" <<'PATCH'
--- a/hello.py
+++ b/hello.py
@@ -1,3 +1,4 @@
+import os
 def hello():
     print("hello world")
PATCH
if check_patch_secrets "$TMPDIR_TEST/clean.patch" 2>/dev/null; then
    pass=$((pass + 1)); echo "ok   - clean patch passes secret check"
else
    fail=$((fail + 1)); echo "FAIL - clean patch should pass secret check"
fi

# Test: patch with AWS key
cat > "$TMPDIR_TEST/aws.patch" <<'PATCH'
--- a/config.py
+++ b/config.py
@@ -1,3 +1,4 @@
+AWS_KEY = "AKIAIOSFODNN7EXAMPLE"
 def connect():
     pass
PATCH
if check_patch_secrets "$TMPDIR_TEST/aws.patch" 2>/dev/null; then
    fail=$((fail + 1)); echo "FAIL - AWS key patch should be flagged"
else
    pass=$((pass + 1)); echo "ok   - AWS key patch is flagged"
fi

# Test: patch with private key
cat > "$TMPDIR_TEST/privkey.patch" <<'PATCH'
--- a/keys.txt
+++ b/keys.txt
@@ -0,0 +1,3 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIEpAIBAAKCAQEA0Z3VS5JJcds3xfn/ygWelFh
+-----END RSA PRIVATE KEY-----
PATCH
if check_patch_secrets "$TMPDIR_TEST/privkey.patch" 2>/dev/null; then
    fail=$((fail + 1)); echo "FAIL - private key patch should be flagged"
else
    pass=$((pass + 1)); echo "ok   - private key patch is flagged"
fi

# Test: patch with GitHub token
cat > "$TMPDIR_TEST/ghtoken.patch" <<'PATCH'
--- a/.env
+++ b/.env
@@ -0,0 +1 @@
+GITHUB_TOKEN=ghp_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghij
PATCH
if check_patch_secrets "$TMPDIR_TEST/ghtoken.patch" 2>/dev/null; then
    fail=$((fail + 1)); echo "FAIL - GitHub token patch should be flagged"
else
    pass=$((pass + 1)); echo "ok   - GitHub token patch is flagged"
fi

# Test: patch with database URL containing password
cat > "$TMPDIR_TEST/dburl.patch" <<'PATCH'
--- a/config.yml
+++ b/config.yml
@@ -0,0 +1 @@
+database_url: postgres://admin:s3cretP4ss@db.example.com:5432/myapp
PATCH
if check_patch_secrets "$TMPDIR_TEST/dburl.patch" 2>/dev/null; then
    fail=$((fail + 1)); echo "FAIL - database URL patch should be flagged"
else
    pass=$((pass + 1)); echo "ok   - database URL with password is flagged"
fi

# Test: patch with password assignment
cat > "$TMPDIR_TEST/passwd.patch" <<'PATCH'
--- a/settings.py
+++ b/settings.py
@@ -0,0 +1 @@
+password = "hunter2isMyP4ssword"
PATCH
if check_patch_secrets "$TMPDIR_TEST/passwd.patch" 2>/dev/null; then
    fail=$((fail + 1)); echo "FAIL - password assignment patch should be flagged"
else
    pass=$((pass + 1)); echo "ok   - password assignment patch is flagged"
fi

# Test: removed secrets (- lines) should NOT be flagged
cat > "$TMPDIR_TEST/removed.patch" <<'PATCH'
--- a/config.py
+++ b/config.py
@@ -1,3 +1,3 @@
-AWS_KEY = "AKIAIOSFODNN7EXAMPLE"
+AWS_KEY = os.environ["AWS_KEY"]
 def connect():
     pass
PATCH
if check_patch_secrets "$TMPDIR_TEST/removed.patch" 2>/dev/null; then
    pass=$((pass + 1)); echo "ok   - removed secret lines are not flagged"
else
    fail=$((fail + 1)); echo "FAIL - removed secret lines should not be flagged"
fi

# Test: warning output contains the banner
output=$(check_patch_secrets "$TMPDIR_TEST/aws.patch" 2>&1 || true)
if echo "$output" | grep -q "WARNING"; then
    pass=$((pass + 1)); echo "ok   - secret detection prints WARNING banner"
else
    fail=$((fail + 1)); echo "FAIL - secret detection should print WARNING banner"
fi

# -- PII detection functional tests --

# Test: clean patch passes PII check
if check_patch_pii "$TMPDIR_TEST/clean.patch" 2>/dev/null; then
    pass=$((pass + 1)); echo "ok   - clean patch passes PII check"
else
    fail=$((fail + 1)); echo "FAIL - clean patch should pass PII check"
fi

# Test: patch with phone number
cat > "$TMPDIR_TEST/phone.patch" <<'PATCH'
--- a/contacts.py
+++ b/contacts.py
@@ -0,0 +1 @@
+emergency_contact = "(555) 123-4567"
PATCH
if check_patch_pii "$TMPDIR_TEST/phone.patch" 2>/dev/null; then
    fail=$((fail + 1)); echo "FAIL - phone number patch should be flagged"
else
    pass=$((pass + 1)); echo "ok   - phone number patch is flagged"
fi

# Test: patch with SSN
cat > "$TMPDIR_TEST/ssn.patch" <<'PATCH'
--- a/data.txt
+++ b/data.txt
@@ -0,0 +1 @@
+ssn: 123-45-6789
PATCH
if check_patch_pii "$TMPDIR_TEST/ssn.patch" 2>/dev/null; then
    fail=$((fail + 1)); echo "FAIL - SSN patch should be flagged"
else
    pass=$((pass + 1)); echo "ok   - SSN patch is flagged"
fi

# Test: patch with personal info field assignments
cat > "$TMPDIR_TEST/pii_fields.patch" <<'PATCH'
--- a/user.py
+++ b/user.py
@@ -0,0 +1 @@
+full_name = "John Doe"
PATCH
if check_patch_pii "$TMPDIR_TEST/pii_fields.patch" 2>/dev/null; then
    fail=$((fail + 1)); echo "FAIL - personal info field patch should be flagged"
else
    pass=$((pass + 1)); echo "ok   - personal info field patch is flagged"
fi

# Test: patch with conversation history (Claude format)
cat > "$TMPDIR_TEST/convo.patch" <<'PATCH'
--- a/log.jsonl
+++ b/log.jsonl
@@ -0,0 +1 @@
+{"type": "human", "message": {"content": "hello"}}
PATCH
if check_patch_pii "$TMPDIR_TEST/convo.patch" 2>/dev/null; then
    fail=$((fail + 1)); echo "FAIL - conversation history patch should be flagged"
else
    pass=$((pass + 1)); echo "ok   - conversation history patch is flagged"
fi

# Test: patch with home directory path
cat > "$TMPDIR_TEST/homedir.patch" <<'PATCH'
--- a/config.py
+++ b/config.py
@@ -0,0 +1 @@
+data_dir = "/Users/johndoe/Documents/private"
PATCH
if check_patch_pii "$TMPDIR_TEST/homedir.patch" 2>/dev/null; then
    fail=$((fail + 1)); echo "FAIL - home directory path patch should be flagged"
else
    pass=$((pass + 1)); echo "ok   - home directory path patch is flagged"
fi

# Test: patch with activity log containing user info
cat > "$TMPDIR_TEST/actlog.patch" <<'PATCH'
--- a/audit.log
+++ b/audit.log
@@ -0,0 +1 @@
+2025-01-15T14:30:00 user=john.doe@company.com login successful
PATCH
if check_patch_pii "$TMPDIR_TEST/actlog.patch" 2>/dev/null; then
    fail=$((fail + 1)); echo "FAIL - activity log patch should be flagged"
else
    pass=$((pass + 1)); echo "ok   - activity log patch is flagged"
fi

# Test: removed PII (- lines) should NOT be flagged
cat > "$TMPDIR_TEST/removed_pii.patch" <<'PATCH'
--- a/user.py
+++ b/user.py
@@ -1,3 +1,3 @@
-full_name = "John Doe"
+full_name = get_name_from_env()
PATCH
if check_patch_pii "$TMPDIR_TEST/removed_pii.patch" 2>/dev/null; then
    pass=$((pass + 1)); echo "ok   - removed PII lines are not flagged"
else
    fail=$((fail + 1)); echo "FAIL - removed PII lines should not be flagged"
fi

# Test: PII warning output contains the banner
output=$(check_patch_pii "$TMPDIR_TEST/phone.patch" 2>&1 || true)
if echo "$output" | grep -q "WARNING"; then
    pass=$((pass + 1)); echo "ok   - PII detection prints WARNING banner"
else
    fail=$((fail + 1)); echo "FAIL - PII detection should print WARNING banner"
fi

# Test: patch with chat log role/content pattern
cat > "$TMPDIR_TEST/chatlog.patch" <<'PATCH'
--- a/export.json
+++ b/export.json
@@ -0,0 +1 @@
+{"role": "user", "content": "What is my account balance?"}
PATCH
if check_patch_pii "$TMPDIR_TEST/chatlog.patch" 2>/dev/null; then
    fail=$((fail + 1)); echo "FAIL - chat log patch should be flagged"
else
    pass=$((pass + 1)); echo "ok   - chat log patch is flagged"
fi

echo ""
echo "$((pass + fail)) tests, $pass passed, $fail failed"
[[ $fail -eq 0 ]]
