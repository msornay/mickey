#!/usr/bin/env python3
"""Tests for mickey CLI."""
import os
import subprocess
import tempfile
from pathlib import Path

MICKEY = Path(__file__).parent / "mickey"


def run(cmd, **kw):
    return subprocess.run(cmd, capture_output=True, text=True, **kw)


# -- Script structure --

def test_syntax():
    assert run(["python3", "-m", "py_compile", str(MICKEY)]).returncode == 0


# -- No args --

def test_no_args_exits_nonzero():
    assert run([str(MICKEY)]).returncode != 0


def test_no_args_shows_usage():
    r = run([str(MICKEY)])
    out = (r.stdout + r.stderr).lower()
    assert "usage:" in out


# -- Unknown command --

def test_unknown_command_exits_nonzero():
    r = run([str(MICKEY), "badcmd"])
    assert r.returncode != 0


# -- Argument parsing --

def test_hire_without_name():
    r = run([str(MICKEY), "hire"])
    assert r.returncode != 0


def test_whip_j_zero():
    r = run([str(MICKEY), "whip", "-j", "0"])
    assert r.returncode != 0


def test_whip_j_nonnumeric():
    r = run([str(MICKEY), "whip", "-j", "abc"])
    assert r.returncode != 0


def test_sh_without_name():
    r = run([str(MICKEY), "sh"])
    assert r.returncode != 0


def test_fire_without_name():
    r = run([str(MICKEY), "fire"])
    assert r.returncode != 0


# -- Agent rules content --

def test_agent_rules_workspace_layout():
    src = MICKEY.read_text()
    assert "Workspace layout" in src


def test_agent_rules_producing_output():
    src = MICKEY.read_text()
    assert "Producing output" in src


def test_agent_rules_make_test():
    src = MICKEY.read_text()
    assert "make test" in src


def test_agent_rules_merge_queue():
    src = MICKEY.read_text()
    assert "merge-queue" in src


def test_agent_rules_deployment():
    src = MICKEY.read_text()
    assert "Deployment awareness" in src


def test_agent_rules_implicit_todo():
    src = MICKEY.read_text()
    assert "implicit todo" in src.lower()


def test_agent_rules_receive_task():
    src = MICKEY.read_text()
    assert "Your task" in src


# -- No old model references --

def test_no_coin_flip():
    src = MICKEY.read_text()
    assert "RANDOM % 2" not in src


def test_no_todo_md_references():
    src = MICKEY.read_text()
    assert "TODO.md" not in src


# -- Task selection --

def test_pick_task_function():
    src = MICKEY.read_text()
    assert "pick_task" in src
    assert "todo" in src
    assert "implicit" in src.lower()


# -- Usage text --

def test_usage_mentions_whip():
    r = run([str(MICKEY)])
    out = r.stdout + r.stderr
    assert "whip" in out


def test_usage_mentions_am():
    r = run([str(MICKEY)])
    out = r.stdout + r.stderr
    assert "am" in out


def test_usage_mentions_status():
    r = run([str(MICKEY)])
    out = r.stdout + r.stderr
    assert "status" in out


# ===== E2E tests with temp workspace =====

def make_workspace(tmp):
    """Create a minimal workspace structure."""
    for d in ["wip", "merge-queue", "repos", "todos"]:
        os.makedirs(f"{tmp}/{d}", exist_ok=True)
    return {**os.environ, "WORKSPACE_DIR": tmp}


def test_status_empty():
    with tempfile.TemporaryDirectory() as ws:
        env = make_workspace(ws)
        r = run([str(MICKEY), "status"], env=env)
        assert "(none)" in r.stdout


def test_status_shows_todo():
    with tempfile.TemporaryDirectory() as ws:
        env = make_workspace(ws)
        Path(f"{ws}/todos/test-task.txt").write_text("Fix the widget")
        r = run([str(MICKEY), "status"], env=env)
        assert "test-task" in r.stdout
        assert "Fix the widget" in r.stdout


def test_status_shows_wip():
    with tempfile.TemporaryDirectory() as ws:
        env = make_workspace(ws)
        Path(f"{ws}/wip/fix-login.txt").write_text("Fix login redirect bug")
        r = run([str(MICKEY), "status"], env=env)
        assert "fix-login" in r.stdout


def test_status_shows_patches():
    with tempfile.TemporaryDirectory() as ws:
        env = make_workspace(ws)
        os.makedirs(f"{ws}/merge-queue/testrepo")
        Path(f"{ws}/merge-queue/testrepo/test.patch").write_text(
            "From abc123 Mon Sep 17 00:00:00 2001\n"
            "From: test [bot] <test@agent.local>\n"
            "Date: Wed, 1 Jan 2026 00:00:00 +0000\n"
            "Subject: [PATCH] Add widget feature\n\n---\n"
        )
        r = run([str(MICKEY), "status"], env=env)
        assert "Add widget feature" in r.stdout


def test_am_no_patches():
    with tempfile.TemporaryDirectory() as ws:
        env = make_workspace(ws)
        r = run([str(MICKEY), "am"], env=env)
        assert r.returncode == 0
        assert "No patches" in r.stdout


def test_reset_confirmed():
    with tempfile.TemporaryDirectory() as ws:
        env = make_workspace(ws)
        os.makedirs(f"{ws}/merge-queue/repo", exist_ok=True)
        Path(f"{ws}/wip/test.txt").write_text("task")
        Path(f"{ws}/merge-queue/repo/test.patch").write_text("patch")
        Path(f"{ws}/todos/task.txt").write_text("todo")
        r = run([str(MICKEY), "reset"], input="y\n", env=env)
        assert not Path(f"{ws}/wip/test.txt").exists()
        assert not Path(f"{ws}/merge-queue/repo/test.patch").exists()
        assert not Path(f"{ws}/todos/task.txt").exists()


def test_reset_aborted():
    with tempfile.TemporaryDirectory() as ws:
        env = make_workspace(ws)
        Path(f"{ws}/wip/test.txt").write_text("task")
        r = run([str(MICKEY), "reset"], input="n\n", env=env)
        assert Path(f"{ws}/wip/test.txt").exists()


def test_lock():
    with tempfile.TemporaryDirectory() as ws:
        env = make_workspace(ws)
        os.makedirs(f"{ws}/repos/testrepo")
        Path(f"{ws}/repos/testrepo/file.txt").write_text("content")
        run([str(MICKEY), "lock"], env=env)
        assert not os.access(f"{ws}/repos/testrepo/file.txt", os.W_OK)
        # Cleanup: restore write so tempdir can be deleted
        run([str(MICKEY), "unlock"], env=env)


def test_unlock():
    with tempfile.TemporaryDirectory() as ws:
        env = make_workspace(ws)
        os.makedirs(f"{ws}/repos/testrepo")
        Path(f"{ws}/repos/testrepo/file.txt").write_text("content")
        run([str(MICKEY), "lock"], env=env)
        run([str(MICKEY), "unlock"], env=env)
        assert os.access(f"{ws}/repos/testrepo/file.txt", os.W_OK)


# -- am with real git repo --

def test_am_applies_patch():
    with tempfile.TemporaryDirectory() as ws:
        env = make_workspace(ws)
        repo = Path(ws) / "repos" / "testrepo"
        repo.mkdir(parents=True)
        # Init a git repo
        subprocess.run(["git", "init"], cwd=repo, capture_output=True)
        subprocess.run(
            ["git", "config", "user.email", "test@test.com"],
            cwd=repo, capture_output=True,
        )
        subprocess.run(
            ["git", "config", "user.name", "Test"],
            cwd=repo, capture_output=True,
        )
        (repo / "file.txt").write_text("hello\n")
        subprocess.run(["git", "add", "."], cwd=repo, capture_output=True)
        subprocess.run(
            ["git", "commit", "-m", "init"], cwd=repo, capture_output=True,
        )
        # Create a patch from a branch
        subprocess.run(
            ["git", "checkout", "-b", "feature"], cwd=repo,
            capture_output=True,
        )
        (repo / "file.txt").write_text("hello world\n")
        subprocess.run(["git", "add", "."], cwd=repo, capture_output=True)
        subprocess.run(
            ["git", "commit", "-m", "add world"],
            cwd=repo, capture_output=True,
        )
        mq = Path(ws) / "merge-queue" / "testrepo"
        mq.mkdir(parents=True, exist_ok=True)
        subprocess.run(
            ["git", "format-patch", "main", "--stdout"],
            cwd=repo, capture_output=True, text=True,
        ).stdout
        patch_content = subprocess.run(
            ["git", "format-patch", "main", "--stdout"],
            cwd=repo, capture_output=True, text=True,
        ).stdout
        # Reset to main
        subprocess.run(
            ["git", "checkout", "main"], cwd=repo, capture_output=True,
        )
        subprocess.run(
            ["git", "branch", "-D", "feature"], cwd=repo,
            capture_output=True,
        )
        (mq / "test.patch").write_text(patch_content)
        r = run([str(MICKEY), "am"], env=env)
        assert r.returncode == 0
        assert "Applying" in r.stdout
        assert not (mq / "test.patch").exists()
        # Verify the patch was applied
        assert "world" in (repo / "file.txt").read_text()


def test_am_failed_patch_creates_todo():
    with tempfile.TemporaryDirectory() as ws:
        env = make_workspace(ws)
        repo = Path(ws) / "repos" / "testrepo"
        repo.mkdir(parents=True)
        subprocess.run(["git", "init"], cwd=repo, capture_output=True)
        subprocess.run(
            ["git", "config", "user.email", "test@test.com"],
            cwd=repo, capture_output=True,
        )
        subprocess.run(
            ["git", "config", "user.name", "Test"],
            cwd=repo, capture_output=True,
        )
        (repo / "file.txt").write_text("hello\n")
        subprocess.run(["git", "add", "."], cwd=repo, capture_output=True)
        subprocess.run(
            ["git", "commit", "-m", "init"], cwd=repo, capture_output=True,
        )
        # Write a bogus patch
        mq = Path(ws) / "merge-queue" / "testrepo"
        mq.mkdir(parents=True, exist_ok=True)
        (mq / "bad.patch").write_text(
            "From abc123 Mon Sep 17 00:00:00 2001\n"
            "From: test <test@test.com>\n"
            "Date: Wed, 1 Jan 2026 00:00:00 +0000\n"
            "Subject: [PATCH] Bad patch\n\n"
            "---\n"
            " nonexistent.txt | 1 +\n"
            " 1 file changed\n\n"
            "diff --git a/nonexistent.txt b/nonexistent.txt\n"
            "--- a/nonexistent.txt\n"
            "+++ b/nonexistent.txt\n"
            "@@ -1 +1,2 @@\n"
            " existing\n"
            "+new line\n"
            "--\n2.0.0\n"
        )
        r = run([str(MICKEY), "am"], env=env)
        assert "FAILED" in r.stdout
        # Check that a fix todo was created
        todos_dir = Path(ws) / "todos"
        fix_files = list(todos_dir.glob("fix-*.txt"))
        assert len(fix_files) == 1
        assert "Bad patch" in fix_files[0].read_text()


if __name__ == "__main__":
    # Simple test runner fallback if pytest isn't available
    import traceback
    tests = [
        v for k, v in sorted(globals().items())
        if k.startswith("test_") and callable(v)
    ]
    passed = failed = 0
    for test in tests:
        try:
            test()
            passed += 1
            print(f"ok   - {test.__name__}")
        except Exception:
            failed += 1
            print(f"FAIL - {test.__name__}")
            traceback.print_exc()
    print(f"\n{passed + failed} tests, {passed} passed, {failed} failed")
    raise SystemExit(1 if failed else 0)
