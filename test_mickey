#!/usr/bin/env bash
# Lean sanity tests for the mickey script.
# Tests argument parsing, usage output, and script structure.
# Does NOT require Docker â€” only validates the script itself.
set -euo pipefail

MICKEY="$(cd "$(dirname "$0")" && pwd)/mickey"
pass=0
fail=0

assert_exits() {
    local expected=$1 desc=$2; shift 2
    local actual=0
    "$@" >/dev/null 2>&1 || actual=$?
    if [[ $actual -eq $expected ]]; then
        pass=$((pass + 1)); echo "ok   - $desc"
    else
        fail=$((fail + 1)); echo "FAIL - $desc (expected exit $expected, got $actual)"
    fi
}

assert_output_matches() {
    local pattern=$1 desc=$2; shift 2
    local output
    output=$("$@" 2>&1) || true
    if echo "$output" | grep -qE "$pattern"; then
        pass=$((pass + 1)); echo "ok   - $desc"
    else
        fail=$((fail + 1)); echo "FAIL - $desc (output missing /$pattern/)"
    fi
}

# -- Script structure --
assert_exits 0 "script passes bash -n syntax check" bash -n "$MICKEY"

# -- No args --
assert_exits 1 "no args exits 1" "$MICKEY"
assert_output_matches "^Usage:" "no args shows usage" "$MICKEY"

# -- Unknown command --
assert_exits 1 "unknown command exits 1" "$MICKEY" badcmd
assert_output_matches "^Usage:" "unknown command shows usage" "$MICKEY" badcmd

# -- hire: missing name --
assert_exits 1 "hire without name exits 1" "$MICKEY" hire
assert_output_matches "mickey hire" "hire without name shows correct usage" "$MICKEY" hire

# -- whip: argument parsing --
assert_exits 1 "whip --model without value exits 1" "$MICKEY" whip --model
assert_exits 1 "whip -j without value exits 1" "$MICKEY" whip -j
assert_exits 1 "whip -j 0 exits 1" "$MICKEY" whip -j 0
assert_exits 1 "whip -j negative exits 1" "$MICKEY" whip -j -1
assert_exits 1 "whip -j non-numeric exits 1" "$MICKEY" whip -j abc
assert_output_matches "positive integer" "whip -j 0 shows error" "$MICKEY" whip -j 0
assert_output_matches "positive integer" "whip -j abc shows error" "$MICKEY" whip -j abc

# -- sh: missing name --
assert_exits 1 "sh without name exits 1" "$MICKEY" sh
assert_output_matches "mickey sh" "sh without name shows correct usage" "$MICKEY" sh

# -- fire: missing name --
assert_exits 1 "fire without name exits 1" "$MICKEY" fire
assert_output_matches "mickey fire" "fire without name shows correct usage" "$MICKEY" fire

# -- Agent rules content --
assert_exits 0 "AGENT_RULES variable is defined" grep -q "^AGENT_RULES=" "$MICKEY"
assert_exits 0 "agent rules contain workspace layout" grep -q "Workspace layout" "$MICKEY"
assert_exits 0 "agent rules contain producing output" grep -q "Producing output" "$MICKEY"
assert_exits 0 "agent rules contain sanity test requirement" grep -q "make test" "$MICKEY"
assert_exits 0 "agent rules contain wip directory" grep -q 'wip/' "$MICKEY"
assert_exits 0 "agent rules contain deployment awareness" grep -q "Deployment awareness" "$MICKEY"
assert_exits 0 "agent rules mention workspace-level TODO.md" grep -q 'WORKSPACE_DIR/TODO.md' "$MICKEY"
assert_exits 0 "agent rules do NOT contain review process" bash -c "! grep -q 'Reviewing patches' '$MICKEY'"
assert_exits 0 "no patch/ directory references in agent rules" bash -c "! grep -q 'WORKSPACE_DIR/patch/' '$MICKEY'"

# -- am: merge-queue cleanup and push --
assert_exits 0 "am cleans up empty merge-queue dirs" grep -q 'rmdir' "$MICKEY"
assert_exits 0 "am tracks applied repos for push" grep -q 'applied_repos' "$MICKEY"
assert_exits 0 "am push uses applied_repos array" grep -q 'applied_repos\[@\]' "$MICKEY"

# -- am: TODO.md update after applying patches --
assert_exits 0 "am collects patch summaries" grep -q 'applied_summaries' "$MICKEY"
assert_exits 0 "am checks for TODO.md before updating" grep -q 'todo_file.*TODO.md' "$MICKEY"
assert_exits 0 "am update prompt instructs to remove addressed items" grep -q 'remove items addressed' "$MICKEY"
assert_exits 0 "am TODO.md update is non-fatal on failure" grep -q 'non-fatal' "$MICKEY"

# -- am: verify_prompt includes PII scanning --
assert_exits 0 "am verify_prompt mentions personal information" grep -q 'personal information' "$MICKEY"
assert_exits 0 "am verify_prompt includes PII categories" grep -q 'Real names' "$MICKEY"
assert_exits 0 "am verify_prompt instructs to delete PII patches" grep -q 'DELETE the patch' "$MICKEY"
assert_exits 0 "am verify_prompt requires semantic understanding beyond regex" grep -q 'semantic understanding' "$MICKEY"
assert_exits 0 "am verify_prompt includes contextual PII category" grep -q 'Contextual PII' "$MICKEY"
assert_exits 0 "am verify_prompt checks for composite identification" grep -q 'Composite identification' "$MICKEY"

# -- Task selection model --
assert_exits 0 "agent rules include coin flip for task source" grep -q 'RANDOM % 2' "$MICKEY"
assert_exits 0 "agent rules describe workspace TODO path" grep -q 'workspace TODO' "$MICKEY"
assert_exits 0 "agent rules describe random repo path" grep -q 'random repo' "$MICKEY"
assert_exits 0 "agent rules allow exit without patch" grep -q 'exit cleanly without producing a patch' "$MICKEY"
assert_exits 0 "no DIFFICULT_TASK_PROMPT variable" bash -c "! grep -q '^DIFFICULT_TASK_PROMPT=' '$MICKEY'"

# -- Agent output prefixing --
assert_exits 0 "whip defines color palette array" grep -q 'colors=(' "$MICKEY"
assert_exits 0 "whip pipes agent output through awk prefix" grep -q 'awk -v name=' "$MICKEY"
assert_exits 0 "awk uses fflush for unbuffered output" grep -q 'fflush()' "$MICKEY"

# -- Usage text --
assert_output_matches "whip" "usage mentions whip command" "$MICKEY"
assert_output_matches "am" "usage mentions am command" "$MICKEY"
assert_output_matches "status" "usage mentions status command" "$MICKEY"
assert_output_matches "wip/" "usage mentions wip directory" "$MICKEY"

# -- Status command structure --
assert_exits 0 "status command is handled in case statement" grep -q "status)" "$MICKEY"
assert_exits 0 "status shows Work In Progress section" grep -q "Work In Progress" "$MICKEY"
assert_exits 0 "status shows Merge Queue section" grep -q "Merge Queue" "$MICKEY"

# -- Whip activity watcher --
assert_exits 0 "whip has activity watcher background loop" grep -q "activity watcher" "$MICKEY"
assert_exits 0 "watcher reports claimed TODOs" grep -q "CLAIMED" "$MICKEY"
assert_exits 0 "watcher reports submitted patches" grep -q ">>> PATCH" "$MICKEY"

# ===== E2E tests (mock workspace, no Docker required) =====

# Helpers to create/destroy a temporary workspace
setup_workspace() {
    TEST_WS=$(mktemp -d)
    mkdir -p "$TEST_WS/wip" "$TEST_WS/merge-queue" "$TEST_WS/repos"
    export WORKSPACE_DIR="$TEST_WS"
}
cleanup_workspace() {
    chmod -R u+w "$TEST_WS" 2>/dev/null || true
    rm -rf "$TEST_WS"
    unset WORKSPACE_DIR
}

# -- status: empty workspace shows (none) --
setup_workspace
assert_output_matches "\\(none\\)" "status: empty workspace shows (none)" "$MICKEY" status
cleanup_workspace

# -- status: displays wip file content --
setup_workspace
cat > "$TEST_WS/wip/test.wip" <<WIP
repo: testrepo
task: test task description
WIP
assert_output_matches "test task description" "status: shows wip claim content" "$MICKEY" status
cleanup_workspace

# -- status: displays patch subjects from merge-queue --
setup_workspace
mkdir -p "$TEST_WS/merge-queue/testrepo"
cat > "$TEST_WS/merge-queue/testrepo/20260101-000000-test.patch" <<PATCH
From abc123 Mon Sep 17 00:00:00 2001
From: test [bot] <test@agent.local>
Date: Wed, 1 Jan 2026 00:00:00 +0000
Subject: [PATCH] Add widget feature

---
PATCH
assert_output_matches "Add widget feature" "status: shows patch subject from merge-queue" "$MICKEY" status
cleanup_workspace

# -- am: no patches exits 0 with message --
setup_workspace
assert_exits 0 "am: no patches exits 0" "$MICKEY" am
assert_output_matches "No patches" "am: no patches shows message" "$MICKEY" am
cleanup_workspace

# -- reset: confirmed with y deletes files --
setup_workspace
touch "$TEST_WS/wip/test.wip"
mkdir -p "$TEST_WS/merge-queue/repo"
touch "$TEST_WS/merge-queue/repo/test.patch"
echo "y" | "$MICKEY" reset >/dev/null 2>&1
if [[ ! -f "$TEST_WS/wip/test.wip" ]] && [[ ! -f "$TEST_WS/merge-queue/repo/test.patch" ]]; then
    pass=$((pass + 1)); echo "ok   - reset: y deletes wip and merge-queue files"
else
    fail=$((fail + 1)); echo "FAIL - reset: y deletes wip and merge-queue files"
fi
cleanup_workspace

# -- reset: aborted with n keeps files --
setup_workspace
touch "$TEST_WS/wip/test.wip"
echo "n" | "$MICKEY" reset >/dev/null 2>&1 || true
if [[ -f "$TEST_WS/wip/test.wip" ]]; then
    pass=$((pass + 1)); echo "ok   - reset: n keeps files intact"
else
    fail=$((fail + 1)); echo "FAIL - reset: n keeps files intact"
fi
cleanup_workspace

# -- lock: makes repos/ read-only --
setup_workspace
mkdir -p "$TEST_WS/repos/testrepo"
touch "$TEST_WS/repos/testrepo/file.txt"
"$MICKEY" lock >/dev/null 2>&1
if [[ ! -w "$TEST_WS/repos/testrepo/file.txt" ]]; then
    pass=$((pass + 1)); echo "ok   - lock: repos become read-only"
else
    fail=$((fail + 1)); echo "FAIL - lock: repos become read-only"
fi
cleanup_workspace

# -- unlock: restores write permissions --
setup_workspace
mkdir -p "$TEST_WS/repos/testrepo"
touch "$TEST_WS/repos/testrepo/file.txt"
"$MICKEY" lock >/dev/null 2>&1
"$MICKEY" unlock >/dev/null 2>&1
if [[ -w "$TEST_WS/repos/testrepo/file.txt" ]]; then
    pass=$((pass + 1)); echo "ok   - unlock: repos become writable again"
else
    fail=$((fail + 1)); echo "FAIL - unlock: repos become writable again"
fi
cleanup_workspace

echo ""
echo "$((pass + fail)) tests, $pass passed, $fail failed"
[[ $fail -eq 0 ]]
