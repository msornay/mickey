#!/usr/bin/env bash
set -euo pipefail

AGENT_RULES='# Agent Rules

You are a developer agent working inside a Docker sandbox.

## Workspace layout
- $WORKSPACE_DIR/ is synced to the host. **NEVER modify files here directly** — only write to wip/ and merge-queue/.
- $WORKSPACE_DIR/repos/ contains git repos. **NEVER write to this directory or any repo inside it.** Only use it as a clone source.
- ~/work/ is your local workspace (not synced). Clone repos here and do all work here.
- $WORKSPACE_DIR/wip/ is the shared work-in-progress directory. Create lock files here to claim TODOs you are working on.
- $WORKSPACE_DIR/merge-queue/<repo>/ is the merge queue, organized by repo. Patches here are ready for the human to apply.

## Default behavior

If you are given no specific task (empty or missing instructions), pick up useful work automatically:

### Pick up a TODO from a repo

1. Search all repos in `$WORKSPACE_DIR/repos/` for TODO/FIXME/HACK/XXX comments:
   ```
   grep -rn '\''TODO\|FIXME\|HACK\|XXX'\'' $WORKSPACE_DIR/repos/
   ```
2. Also check for a `TODO.md` or `TODO` file in each repo root.
3. Also check for a `TODO.md` at the workspace root (`$WORKSPACE_DIR/TODO.md`). Workspace-level TODOs may reference specific repos — treat them the same as repo-level TODOs.
4. Also check for **implicit TODOs**: repos that do not follow standard conventions. Every repo should have a Makefile with at least these targets: `test` (sanity tests), `deploy` (deployment automation). If a repo is missing these, creating them is an implicit TODO.
5. **Check existing patches.** Read patch files in `$WORKSPACE_DIR/merge-queue/<repo>/` and examine their commit messages (the `Subject:` line). Skip TODOs already addressed by an existing patch.
6. **Check for in-progress work.** Read all `.wip` files in `$WORKSPACE_DIR/wip/`. Each is a short message from another agent describing what they'\''re working on. Skip any TODO that overlaps with an existing wip message (same repo and similar intent, even if worded differently).
7. **Skip TODOs that have unmet prerequisites.** If a TODO depends on other TODOs being completed first (e.g., it references another task, needs infrastructure that doesn'\''t exist yet, or is sequenced after other items in TODO.md), skip it. Only pick TODOs whose prerequisites are already done or that have no dependencies.
8. Collect all actionable TODOs into a list and **select one at random**. Do NOT always pick the first or "most important" one — randomize to reduce collision with other agents.
9. **Wait a random delay between 0 and 30 seconds** to stagger agent starts:
   ```
   sleep $((RANDOM % 30))
   ```
10. **Re-read wip/** after the delay — another agent may have claimed the same TODO while you waited. If your chosen TODO now overlaps with a new wip message, pick a different one.
11. Claim the TODO by posting a `.wip` file describing your intent:
   ```
   cat > $WORKSPACE_DIR/wip/$(date +%Y%m%d-%H%M%S)-$(hostname).wip <<WIP
   repo: <repo>
   task: <one-line description of what you are about to do>
   WIP
   ```
12. Work on it using the normal "Starting work" and "Producing output" process.
13. In your commit message, reference the original TODO (file and line number) so it can be traced back.

### If there is nothing to do

If there are no actionable TODOs (explicit or implicit) in the repos, say so and stop.

## Starting work
1. Get the repo(s) you need. If ~/work/<repo> doesn'\''t exist, clone it:
     git clone $WORKSPACE_DIR/repos/<repo> ~/work/<repo>
   If it already exists, pull latest:
     cd ~/work/<repo> && git checkout main && git pull $WORKSPACE_DIR/repos/<repo> main
2. Work on a descriptive branch:
     cd ~/work/<repo> && git checkout -b <branch-name>
3. Set git author to identify this agent and model:
     cd ~/work/<repo>
     git config user.name "$(hostname) [bot]"
     git config user.email "$(hostname)+${ANTHROPIC_MODEL:-claude}@agent.local"

## Producing output
When your task is complete, run sanity tests and produce a patch:

1. **Run sanity tests.** Every repo must have a Makefile with a `test` target. Run it before producing a patch:
   ```
   cd ~/work/<repo>
   make test
   ```
   If tests fail, fix them before proceeding. Do NOT submit a patch with failing tests.

2. **Squash to a single commit** with a datetime-prefixed patch:
   ```
   TIMESTAMP=$(date +%Y%m%d-%H%M%S)
   cd ~/work/<repo>
   git checkout -b squash-tmp main
   git merge --squash <branch-name>
   git commit -m "<descriptive message>"
   ```

3. **If the patch addresses a repo TODO**: check if the repo has a `TODO.md` (or `TODO`) file and the commit clearly addresses one of its items. If so, remove the addressed line(s) from that file and amend the commit:
   ```
   # edit TODO.md to remove the addressed item(s)
   git add TODO.md
   git commit --amend --no-edit
   ```

4. **Create the merge-queue subdirectory if needed and produce the patch:**
   ```
   mkdir -p $WORKSPACE_DIR/merge-queue/<repo>
   git format-patch main --stdout > $WORKSPACE_DIR/merge-queue/<repo>/${TIMESTAMP}-$(hostname)-<short-name>.patch
   ```

5. **Verify the patch applies cleanly:**
   ```
   cd ~/work/<repo>
   git checkout main
   git am --check $WORKSPACE_DIR/merge-queue/<repo>/${TIMESTAMP}-$(hostname)-<short-name>.patch
   ```
   If it fails, fix your branch and regenerate the patch.

6. **Clean up your wip file** after submitting the patch:
   ```
   rm -f $WORKSPACE_DIR/wip/*-$(hostname).wip
   ```

## Deployment awareness
Deploying code is done by a human, not by agents. When your work involves deployment-relevant changes (configuration, infrastructure, environment variables, etc.):

1. Write clear documentation about the deployment steps needed.
2. If the repo has a `deploy` target in its Makefile, ensure your changes are compatible with it.
3. If the repo does NOT have a `deploy` target and your changes require deployment steps, create one as part of your patch. The `deploy` target should automate the configured deployment process.
4. Include deployment notes in your commit message when relevant.

## Rules
- NEVER write to $WORKSPACE_DIR/ except $WORKSPACE_DIR/wip/ and $WORKSPACE_DIR/merge-queue/. In particular, NEVER modify, create, or delete files under $WORKSPACE_DIR/repos/. Corrupting host repos is unrecoverable.
- NEVER enter plan mode. Do the work directly and produce a patch.
- NEVER push to any remote
- NEVER create pull requests
- Always run `make test` before producing a patch. Never submit a patch with failing sanity tests.
- Make clean, atomic commits with good messages
- Select TODOs at random — do not always pick the same one'

DEFAULT_PROMPT="Follow your default behavior instructions: find TODOs in repos and work on them."

usage() {
  cat <<'USAGE'
Usage: mickey <command> [args]

Commands:
  hire  <name>                               Create agent and auth (interactive)
  whip  [--model <model>] [-j N] [prompts]   Send agents to work (Ctrl-C to stop)
  sh    <name>                               Shell into agent
  ls                                         List agents
  fire  <name>                               Remove agent
  am    [--push]                             Verify and apply patches from merge-queue/
  status                                     Show wip claims, queued patches, and agents
  lock                                       Make repos/ read-only
  unlock                                     Restore repos/ write permissions
  reset                                      Clear wip/ and merge-queue/ (with confirmation)
USAGE
  exit 1
}

[[ $# -eq 0 ]] && usage

cmd=$1; shift

case "$cmd" in
  hire)
    [[ $# -lt 1 ]] && { echo "Usage: mickey hire <name>"; exit 1; }
    docker sandbox create --name "$1" claude ~/src
    docker sandbox run "$1"
    ;;
  whip)
    model=""
    if [[ "${1:-}" == "--model" ]]; then
      [[ $# -lt 2 ]] && { echo "Usage: mickey whip [--model <model>] [-j N] [prompts...]"; exit 1; }
      shift; model="$1"; shift
    fi

    # Determine mode and collect prompts
    prompts=()
    agent_count=0

    if [[ "${1:-}" == "-j" ]]; then
      [[ $# -lt 2 ]] && { echo "Usage: mickey whip [--model <model>] -j <N> [prompts...]"; exit 1; }
      shift; agent_count=$1; shift
      [[ "$agent_count" =~ ^[1-9][0-9]*$ ]] || { echo "Error: -j requires a positive integer, got '$agent_count'." >&2; exit 1; }
      prompts=("$@")
    elif [[ $# -gt 0 ]]; then
      IFS=':' read -ra prompts <<< "$*"
      agent_count=${#prompts[@]}
    fi

    # Get available agents
    all_names=()
    while IFS= read -r n; do all_names+=("$n"); done < <(docker sandbox ls | awk 'NR>1 {print $1}')
    [[ ${#all_names[@]} -eq 0 ]] && { echo "No agents found. Hire some first: mickey hire <name>"; exit 0; }

    if [[ $agent_count -gt 0 ]]; then
      [[ ${#all_names[@]} -lt $agent_count ]] && { echo "Requested $agent_count agents but only ${#all_names[@]} available." >&2; exit 1; }
      selected=("${all_names[@]:0:$agent_count}")
    else
      selected=("${all_names[@]}")
    fi

    # Color palette for distinguishing agents (ANSI color codes)
    colors=(36 32 33 35 34 31)  # cyan, green, yellow, magenta, blue, red

    ws="${WORKSPACE_DIR:-$HOME/src}"
    wip_dir="$ws/wip"
    queue_dir="$ws/merge-queue"

    stop_all() {
      kill 0
      for n in "${selected[@]}"; do docker sandbox stop "$n" 2>/dev/null & done
      wait
    }
    trap 'stop_all; exit 0' INT TERM EXIT

    # Background activity watcher: prints when agents claim TODOs or submit patches
    (
      prev_wip=$(ls "$wip_dir"/*.wip 2>/dev/null | sort || true)
      prev_patches=$(find "$queue_dir" -name '*.patch' -type f 2>/dev/null | sort || true)
      while true; do
        sleep 10
        cur_wip=$(ls "$wip_dir"/*.wip 2>/dev/null | sort || true)
        if [[ "$cur_wip" != "$prev_wip" ]]; then
          # Find new wip files
          while IFS= read -r f; do
            [[ -z "$f" ]] && continue
            echo ">>> CLAIMED: $(cat "$f")"
          done < <(comm -13 <(echo "$prev_wip") <(echo "$cur_wip"))
          # Report cleared wip files
          while IFS= read -r f; do
            [[ -z "$f" ]] && continue
            echo ">>> DONE: $(basename "$f" .wip)"
          done < <(comm -23 <(echo "$prev_wip") <(echo "$cur_wip"))
          prev_wip="$cur_wip"
        fi
        cur_patches=$(find "$queue_dir" -name '*.patch' -type f 2>/dev/null | sort || true)
        if [[ "$cur_patches" != "$prev_patches" ]]; then
          while IFS= read -r f; do
            [[ -z "$f" ]] && continue
            repo=$(basename "$(dirname "$f")")
            subject=$(head -10 "$f" | grep '^Subject:' | sed 's/^Subject: \[PATCH[^]]*\] //')
            echo ">>> PATCH: $repo — $subject"
          done < <(comm -13 <(echo "$prev_patches") <(echo "$cur_patches"))
          prev_patches="$cur_patches"
        fi
      done
    ) &

    for i in "${!selected[@]}"; do
      name="${selected[$i]}"
      color="${colors[$((i % ${#colors[@]}))]}"

      if [[ $i -lt ${#prompts[@]} ]] && [[ -n "${prompts[$i]}" ]]; then
        agent_prompt="${prompts[$i]}"
      else
        agent_prompt="$DEFAULT_PROMPT"
      fi

      (
        trap 'kill %% 2>/dev/null; exit 0' INT TERM
        while true; do
          if [[ -n "$model" ]]; then
            echo "Sending $name to work ($model)..."
            ANTHROPIC_MODEL="$model" docker sandbox run "$name" -- \
              --append-system-prompt "$AGENT_RULES" -p "$agent_prompt" &
          else
            echo "Sending $name to work..."
            docker sandbox run "$name" -- \
              --append-system-prompt "$AGENT_RULES" -p "$agent_prompt" &
          fi
          wait $!
          exit_code=$?
          if [[ $exit_code -eq 1 ]]; then
            echo "$name exited with code 1 (credits exhausted?). Waiting 5 minutes before retry..." >&2
            sleep 300 &
            wait $!
          fi
        done
      ) 2>&1 | awk -v name="$name" -v color="$color" \
        '{printf "\033[" color "m[" name "]\033[0m %s\n", $0; fflush()}' &
    done
    wait
    ;;
  sh)
    [[ $# -lt 1 ]] && { echo "Usage: mickey sh <name>"; exit 1; }
    docker sandbox exec -it "$1" bash
    ;;
  ls)
    docker sandbox ls
    ;;
  fire)
    [[ $# -lt 1 ]] && { echo "Usage: mickey fire <name>"; exit 1; }
    docker sandbox rm "$1"
    ;;
  am)
    push=false
    if [[ "${1:-}" == "--push" ]]; then
      push=true; shift
    fi
    ws="${WORKSPACE_DIR:-$HOME/src}"
    repos_dir="$ws/repos"
    queue_dir="$ws/merge-queue"

    # Check merge-queue has patches
    patch_count=$(find "$queue_dir" -name '*.patch' -type f 2>/dev/null | wc -l | tr -d ' ')
    if [[ "$patch_count" -eq 0 ]]; then
      echo "No patches in $queue_dir."
      exit 0
    fi

    # Step 1: Launch agent to verify and fix all patches
    echo "Verifying $patch_count patch(es)..."
    verify_prompt="Your goal: ensure every .patch file in $queue_dir applies cleanly AND contains no personal information. Do NOT stop until all patches pass both checks.

For each subdirectory in $queue_dir/, the directory name is a repo name.

## Part 1: Patch application

For each repo:
  1. Clone or update: cd ~/work/<repo> (clone from $repos_dir/<repo> if needed, or git checkout main && git pull)
  2. Try each .patch file (sorted by name): git am --check <patch-file>
  3. If a patch fails:
     - Diagnose the conflict (check what changed in main since the patch was created)
     - Apply the patch with git am in a temporary branch, resolve conflicts manually
     - Regenerate a clean patch: git format-patch main --stdout > <same-patch-path>
     - Reset to main and verify the new patch: git checkout main && git am --check <patch-file>
     - Repeat until it applies cleanly
  4. If a patch is truly unfixable (e.g. the entire feature was already landed), delete it from $queue_dir

## Part 2: Personal information scan

After all patches apply cleanly, review each patch for personal information leaks.

**IMPORTANT**: Go beyond simple pattern matching. Use semantic understanding to identify PII that regular expressions would miss. Read the full diff content (added lines) of every patch, understand the context, and flag any of the following:

### Direct identifiers
- **Real names** of people (in comments, test data, variable values, commit messages beyond the author line)
- **Real email addresses** that appear to belong to actual people (not placeholder/test addresses like user@example.com)
- **Phone numbers** in any format (international, local, with/without separators)
- **Physical addresses** (street addresses, postal codes tied to specific locations)
- **Government IDs** (SSN, national ID numbers, passport numbers, tax IDs)
- **Usernames, account IDs, or session tokens** that could identify real users

### Sensitive personal data
- **Dates of birth** or ages tied to identifiable individuals
- **Financial information** (bank account numbers, credit card numbers, salary figures tied to individuals)
- **Health or biometric data** tied to identifiable individuals
- **Conversation logs or chat transcripts** containing real user messages

### Contextual PII (requires semantic understanding, not just regex)
- **Internal hostnames, server names, or IP addresses** that reveal infrastructure details
- **File paths containing real usernames** (e.g., /Users/jsmith/ or /home/jdoe/) — even when embedded in error messages, stack traces, or config values
- **Organizational details** that could identify individuals (specific team names, office locations, employee IDs, internal project codenames)
- **Behavioral data** (browsing history, search queries, purchase history, location check-ins) tied to identifiable people
- **Composite identification** — combinations of seemingly innocuous data that together identify a person (e.g., job title + city + employer, or age + profession + neighborhood)
- **Screenshots, logs, or debug output** that incidentally contain real user data
- **Hardcoded personal data** in test fixtures, seed files, or example configs that looks like it belongs to a real person rather than being clearly fictional
- **Copy-pasted terminal output** containing prompts with usernames, paths, or environment variables that reveal identity

### How to evaluate
Use your judgment and contextual reasoning — not just pattern matching. Ask yourself:
- Does this data point look like it belongs to a real person, or is it clearly synthetic/fictional?
- Could combining multiple data points in this patch identify someone?
- Is this an internal detail (hostname, path, project name) that was accidentally included?

Obviously fictional data (John Doe, 123 Fake Street, 555-0100) is fine. Data that looks like it could belong to a real person is not. When in doubt, flag it.

If you find PII in a patch:
  1. Print a clear warning identifying the patch file and the problematic content
  2. DELETE the patch from $queue_dir (do not attempt to fix it — the agent should redo it)

When finished: every remaining patch in $queue_dir must pass git am --check AND be free of personal information. Do a final pass to confirm both."

    agent=$(docker sandbox ls | awk 'NR>1 {print $1; exit}')
    if [[ -z "$agent" ]]; then
      echo "No agents available. Hire one first: mickey hire <name>" >&2
      exit 1
    fi

    verify_exit=0
    ANTHROPIC_MODEL="claude-sonnet-4-6" docker sandbox run "$agent" -- \
      --append-system-prompt "$AGENT_RULES" -p "$verify_prompt" || verify_exit=$?

    if [[ $verify_exit -ne 0 ]]; then
      echo "Verification failed (agent exited $verify_exit). Patches NOT applied." >&2
      exit 1
    fi

    # Step 2: Apply patches in chronological order (by filename timestamp)
    echo "Applying patches..."
    applied_repos=()
    while IFS= read -r patch_file; do
      repo_dir=$(dirname "$patch_file")
      repo=$(basename "$repo_dir")
      target="$repos_dir/$repo"
      if [[ ! -d "$target/.git" ]]; then
        echo "Warning: $target is not a git repo, skipping." >&2
        continue
      fi
      echo "  Applying $(basename "$patch_file") to $repo..."
      (cd "$target" && git am "$patch_file") || {
        echo "FAILED to apply $(basename "$patch_file") to $repo. Aborting." >&2
        (cd "$target" && git am --abort 2>/dev/null || true)
        exit 1
      }
      rm "$patch_file"
      case " ${applied_repos[*]:-} " in
        *" $repo "*) ;;
        *) applied_repos+=("$repo") ;;
      esac
      # Clean up empty merge-queue repo directory
      rmdir "$repo_dir" 2>/dev/null && echo "  Cleaned up empty $queue_dir/$repo/"
    done < <(find "$queue_dir" -name '*.patch' -type f | while IFS= read -r f; do echo "$(basename "$f") $f"; done | sort | cut -d' ' -f2-)
    echo "All patches applied."

    # Step 3: Push if --push was given
    if $push; then
      echo "Pushing repos..."
      for repo in "${applied_repos[@]}"; do
        target="$repos_dir/$repo"
        echo "  Pushing $repo main..."
        (cd "$target" && git push origin main) || {
          echo "FAILED to push $repo." >&2
          exit 1
        }
      done
      echo "All repos pushed."
    fi
    ;;
  status)
    ws="${WORKSPACE_DIR:-$HOME/src}"
    wip_dir="$ws/wip"
    queue_dir="$ws/merge-queue"

    echo "=== Agents ==="
    docker sandbox ls 2>/dev/null || echo "  (docker not available)"
    echo ""

    echo "=== Work In Progress ==="
    wip_found=0
    for f in "$wip_dir"/*.wip; do
      [[ -f "$f" ]] || continue
      wip_found=1
      echo "  $(cat "$f")"
    done
    [[ $wip_found -eq 0 ]] && echo "  (none)"
    echo ""

    echo "=== Merge Queue ==="
    patch_found=0
    for repo_dir in "$queue_dir"/*/; do
      [[ -d "$repo_dir" ]] || continue
      repo=$(basename "$repo_dir")
      for patch_file in "$repo_dir"*.patch; do
        [[ -f "$patch_file" ]] || continue
        patch_found=1
        subject=$(head -10 "$patch_file" | grep '^Subject:' | sed 's/^Subject: \[PATCH[^]]*\] //')
        echo "  $repo: $subject"
      done
    done
    [[ $patch_found -eq 0 ]] && echo "  (none)"
    ;;
  lock)
    repos_dir="${WORKSPACE_DIR:-$HOME/src}/repos"
    chmod -R a-w "$repos_dir"
    echo "Locked $repos_dir (read-only)."
    ;;
  unlock)
    repos_dir="${WORKSPACE_DIR:-$HOME/src}/repos"
    chmod -R u+w "$repos_dir"
    echo "Unlocked $repos_dir (writable)."
    ;;
  reset)
    ws="${WORKSPACE_DIR:-$HOME/src}"
    wip_dir="$ws/wip"
    queue_dir="$ws/merge-queue"
    wip_count=$(find "$wip_dir" -type f ! -name '.DS_Store' 2>/dev/null | wc -l | tr -d ' ')
    queue_count=$(find "$queue_dir" -type f ! -name '.DS_Store' 2>/dev/null | wc -l | tr -d ' ')
    echo "This will delete:"
    echo "  $wip_count file(s) in $wip_dir"
    echo "  $queue_count file(s) in $queue_dir"
    printf "Continue? [y/N] "
    read -r answer
    [[ "$answer" =~ ^[Yy]$ ]] || { echo "Aborted."; exit 1; }
    find "$wip_dir" -type f ! -name '.DS_Store' -delete 2>/dev/null || true
    find "$queue_dir" -type f ! -name '.DS_Store' -delete 2>/dev/null || true
    find "$queue_dir" -mindepth 1 -type d -empty -delete 2>/dev/null || true
    echo "Done."
    ;;
  *)
    usage
    ;;
esac
