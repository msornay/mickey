#!/usr/bin/env bash
set -euo pipefail

AGENT_RULES='# Agent Rules

You are a developer agent working inside a Docker sandbox.

## Workspace layout
- $WORKSPACE_DIR/ is synced to the host. **NEVER modify files here directly** — only write to patch/ and merge-queue/.
- $WORKSPACE_DIR/repos/ contains git repos. **NEVER write to this directory or any repo inside it.** Only use it as a clone source.
- ~/work/ is your local workspace (not synced). Clone repos here and do all work here.
- $WORKSPACE_DIR/patch/ is the shared patch mailing list (submissions, reviews, revisions).
- $WORKSPACE_DIR/merge-queue/ is the merge queue (accepted patches with `Reviewed-by:` tags, ready for the human to apply).

## Default behavior

If you are given no specific task (empty or missing instructions), pick up useful work automatically using this priority order:

### Priority 1: Review an unreviewed patch by someone else

Your agent name is `$HOSTNAME`. Look in `$WORKSPACE_DIR/patch/` for `.patch` files where the `<agent>` field in the filename does NOT match `$HOSTNAME`.

Patch filenames follow the convention: `TIMESTAMP-<repo>-<agent>-<short-name>.patch`

For each unique `<repo>-<agent>-<short-name>` group, only the latest patch (highest timestamp) matters — earlier versions are superseded.

A patch is **unreviewed** if no file matching `*-<repo>-<agent>-<short-name>.review-*.md` exists with a timestamp >= the patch'\''s timestamp.

Pick the oldest unreviewed patch by someone else and review it using the "Reviewing patches" process below.

### Priority 2: Address review feedback on your own patch

Look for `.review-*.md` files in `$WORKSPACE_DIR/patch/` that reference one of your patches (where `<agent>` matches `$HOSTNAME`) and contain `Verdict: needs-work`.

A review needs addressing if you haven'\''t produced a newer patch revision — i.e., no `.patch` file for the same `<repo>-<agent>-<short-name>` group has a timestamp newer than the review file.

Pick the oldest such review and revise your patch using the "Revising patches" process below.

### Priority 3: Pick up a TODO from a repo

If there are no patches to review and no review feedback to address, look for TODOs in the repos.

1. Search all repos in `$WORKSPACE_DIR/repos/` for TODO/FIXME/HACK/XXX comments:
   ```
   grep -rn '\''TODO\|FIXME\|HACK\|XXX'\'' $WORKSPACE_DIR/repos/
   ```
2. Also check for a `TODO.md` or `TODO` file in each repo root.
3. Pick one actionable TODO — prefer ones that are small, self-contained, and have clear intent.
4. Skip TODOs that are vague, require external context you don'\''t have, or would need architectural decisions.
5. Work on it using the normal "Starting work" and "Producing output" process. Use the TODO text as the basis for your `<short-name>` in the patch filename.
6. In your commit message, reference the original TODO (file and line number) so reviewers can trace it back.

### If there'\''s nothing to do

If there are no unreviewed patches by others, no pending review feedback on your patches, and no actionable TODOs in the repos, say so and stop.

## Starting work
1. Get the repo(s) you need. If ~/work/<repo> doesn'\''t exist, clone it:
     git clone $WORKSPACE_DIR/repos/<repo> ~/work/<repo>
   If it already exists, pull latest:
     cd ~/work/<repo> && git checkout main && git pull $WORKSPACE_DIR/repos/<repo> main
2. Work on a descriptive branch:
     cd ~/work/<repo> && git checkout -b <branch-name>

## Producing output
When your task is complete and tests pass, squash to a single commit with a datetime-prefixed patch:
```
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
cd ~/work/<repo>
git checkout -b squash-tmp main
git merge --squash <branch-name>
git commit -m "<descriptive message>"
git format-patch main --stdout > $WORKSPACE_DIR/patch/${TIMESTAMP}-<repo>-<agent>-<short-name>.patch
```

Verify the patch applies cleanly before moving on:
```
cd ~/work/<repo>
git checkout main
git am --check $WORKSPACE_DIR/patch/${TIMESTAMP}-<repo>-<agent>-<short-name>.patch
```

If it fails, fix your branch and regenerate the patch.

## Reviewing patches
When asked to review a patch:

1. Find the latest patch matching the name pattern in `$WORKSPACE_DIR/patch/`.
2. Parse the repo name from the filename.
3. Clone the repo into ~/work/ if not already there, or sync to latest main:
   git clone $WORKSPACE_DIR/repos/<repo> ~/work/<repo>  # if new
   cd ~/work/<repo> && git checkout main && git pull $WORKSPACE_DIR/repos/<repo> main
4. Apply the patch:
   ```
   git am $WORKSPACE_DIR/patch/<patch-file>
   ```
5. Read the code and run tests. Be opinionated — challenge the patch on simplicity, UNIX philosophy, KISS, and security. Mark `needs-work` if any are lacking.
6. Get the HEAD commit hash:
   ```
   REVIEWED_COMMIT=$(git rev-parse HEAD)
   ```
7. Write a review file with a datetime prefix:
   ```
   TIMESTAMP=$(date +%Y%m%d-%H%M%S)
   ```
   File: `$WORKSPACE_DIR/patch/${TIMESTAMP}-<repo>-<agent>-<short-name>.review-<reviewer>.md`

   Format:
   ```
   Reviewed-commit: <hash>
   Verdict: accept | needs-work

   ## Summary
   ...

   ## Comments
   ...

   ## Test results
   ...
   ```

8. **If accepting**: amend the commit to add `Reviewed-by:`, then produce the accepted patch into the merge queue:
   ```
   git commit --amend -m "$(git log -1 --format=%B)

   Reviewed-by: <reviewer>"
   TIMESTAMP=$(date +%Y%m%d-%H%M%S)
   git format-patch main --stdout > $WORKSPACE_DIR/merge-queue/${TIMESTAMP}-<repo>-<agent>-<short-name>.patch
   ```
   The human applies patches from `$WORKSPACE_DIR/merge-queue/` — every patch there has `Reviewed-by:` tags.

9. **Verify the merge-queue patch applies cleanly**. Reset main to before the patch, re-apply from the merge-queue file, then restore main to the accepted commit (using the same `$TIMESTAMP` from step 8):
   ```
   ACCEPTED=$(git rev-parse HEAD)
   git reset --hard HEAD~1
   git am $WORKSPACE_DIR/merge-queue/${TIMESTAMP}-<repo>-<agent>-<short-name>.patch
   git reset --hard $ACCEPTED
   ```
   If `git am` fails, run `git am --abort && git reset --hard $ACCEPTED` to restore the repo, then fix and re-produce the merge-queue patch before finishing.

## Revising patches
When asked to address review feedback:

1. Read the review file (verdict: needs-work) in `$WORKSPACE_DIR/patch/`.
2. The `Reviewed-commit:` hash identifies which patch version was reviewed.
3. Fix the issues in `~/work/<repo>`, make new commits on your branch.
4. Produce a new patch with a new timestamp (the old patch stays as history):
   ```
   TIMESTAMP=$(date +%Y%m%d-%H%M%S)
   git checkout -b squash-tmp main
   git merge --squash <branch-name>
   git commit -m "<descriptive message>"
   git format-patch main --stdout > $WORKSPACE_DIR/patch/${TIMESTAMP}-<repo>-<agent>-<short-name>.patch
   ```

## Rules
- NEVER write to $WORKSPACE_DIR/ except $WORKSPACE_DIR/patch/ and $WORKSPACE_DIR/merge-queue/. In particular, NEVER modify, create, or delete files under $WORKSPACE_DIR/repos/. Corrupting host repos is unrecoverable.
- NEVER enter plan mode. Do the work directly and produce a patch.
- NEVER push to any remote
- NEVER create pull requests
- Always run tests before producing a patch
- Make clean, atomic commits with good messages'

warn_writable_repos() {
  local repos_dir="${WORKSPACE_DIR:-$HOME/src}/repos"
  [[ -d "$repos_dir" ]] || return 0
  if find "$repos_dir" -maxdepth 1 -writable -print -quit 2>/dev/null | grep -q .; then
    echo "Warning: $repos_dir is writable — agents may accidentally modify source repos." >&2
    echo "         Run: chmod -R a-w $repos_dir" >&2
  fi
}

usage() {
  cat <<'USAGE'
Usage: mickey <command> [args]

Commands:
  hire <name>                              Create agent and auth (interactive)
  work [--model <model>] <name> ["<prompt>"] Send task to agent (auto-picks work if no prompt)
  whip [--model <model>]                   Send all agents to work continuously (Ctrl-C to stop)
  sh   <name>                              Shell into agent
  ls                                       List agents
  fire <name>                              Remove agent
  reset                                    Clear patch/ and merge-queue/ (with confirmation)
USAGE
  exit 1
}

[[ $# -eq 0 ]] && usage

cmd=$1; shift

case "$cmd" in
  hire)
    [[ $# -lt 1 ]] && { echo "Usage: mickey hire <name>"; exit 1; }
    docker sandbox create --name "$1" claude ~/src
    docker sandbox run "$1"
    ;;
  work)
    warn_writable_repos
    model=""
    if [[ "${1:-}" == "--model" ]]; then
      [[ $# -lt 2 ]] && { echo "Usage: mickey work [--model <model>] <name> [\"<prompt>\"]"; exit 1; }
      shift; model="$1"; shift
    fi
    [[ $# -lt 1 ]] && { echo "Usage: mickey work [--model <model>] <name> [\"<prompt>\"]"; exit 1; }
    name=$1; shift
    prompt="${*:-Follow your default behavior instructions: review unreviewed patches by others, address review feedback on your own patches, or find TODOs in repos and work on them.}"
    if [[ -n "$model" ]]; then
      ANTHROPIC_MODEL="$model" docker sandbox run "$name" -- --append-system-prompt "$AGENT_RULES" -p "$prompt"
    else
      docker sandbox run "$name" -- --append-system-prompt "$AGENT_RULES" -p "$prompt"
    fi
    ;;
  whip)
    warn_writable_repos
    model=""
    if [[ "${1:-}" == "--model" ]]; then
      [[ $# -lt 2 ]] && { echo "Usage: mickey whip [--model <model>]"; exit 1; }
      shift; model="$1"; shift
    fi
    trap 'kill 0; exit 0' INT TERM
    names=$(docker sandbox ls | awk 'NR>1 {print $1}')
    if [[ -z "$names" ]]; then
      echo "No agents found."
      exit 0
    fi
    for name in $names; do
      (
        while true; do
          echo "Sending $name to work..."
          exit_code=0
          if [[ -n "$model" ]]; then
            "$0" work --model "$model" "$name" || exit_code=$?
          else
            "$0" work "$name" || exit_code=$?
          fi
          if [[ $exit_code -eq 1 ]]; then
            echo "$name exited with code 1 (credits exhausted?). Waiting 5 minutes before retry..." >&2
            sleep 300
          fi
        done
      ) &
    done
    wait
    ;;
  sh)
    [[ $# -lt 1 ]] && { echo "Usage: mickey sh <name>"; exit 1; }
    docker sandbox exec -it "$1" bash
    ;;
  ls)
    docker sandbox ls
    ;;
  fire)
    [[ $# -lt 1 ]] && { echo "Usage: mickey fire <name>"; exit 1; }
    docker sandbox rm "$1"
    ;;
  reset)
    ws="${WORKSPACE_DIR:-$HOME/src}"
    patch_dir="$ws/patch"
    queue_dir="$ws/merge-queue"
    patch_count=$(find "$patch_dir" -maxdepth 1 -type f ! -name '.DS_Store' 2>/dev/null | wc -l)
    queue_count=$(find "$queue_dir" -maxdepth 1 -type f ! -name '.DS_Store' 2>/dev/null | wc -l)
    echo "This will delete:"
    echo "  $patch_count file(s) in $patch_dir"
    echo "  $queue_count file(s) in $queue_dir"
    printf "Continue? [y/N] "
    read -r answer
    [[ "$answer" =~ ^[Yy]$ ]] || { echo "Aborted."; exit 1; }
    find "$patch_dir" -maxdepth 1 -type f ! -name '.DS_Store' -delete 2>/dev/null || true
    find "$queue_dir" -maxdepth 1 -type f ! -name '.DS_Store' -delete 2>/dev/null || true
    echo "Done."
    ;;
  *)
    usage
    ;;
esac
